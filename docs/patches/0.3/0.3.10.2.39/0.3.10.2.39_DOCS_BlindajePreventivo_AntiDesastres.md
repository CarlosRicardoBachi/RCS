# 0.3.10.2.39 — DOCS — Blindaje preventivo (anti-desastres)

Este patch es **solo documentación**. No cambia runtime ni versión; cambia el “contrato” de cómo se entregan y aplican parches para evitar cadenas de hotfixes que terminan rompiendo el arranque.

## Qué pasó (patrón de fallo)

El desastre típico fue este combo:

1. **Patch que toca `ui/main_window.py`** (archivo grande, sensible) + cambios parciales.
2. El patch introduce un **método referenciado pero no definido** (o definido con indent roto), y eso explota en import/boot.
3. Se “arregla” con otro hotfix que **parchea arriba de un estado ya inconsistente**, sin un test de arranque automático.
4. Se pierde “el último estado estable” y aparece **deriva de rutas** (scripts/hotfix apuntando a rutas fuera del repo).

La causa raíz no es “falta de documentación”, es **falta de *reglas ejecutables*** y de un *protocolo de rollback*.

---

## Reglas Anti‑Desastres (obligatorias)

### R0 — Patch = unidad atómica + reversible
Todo patch debe incluir:

- **Qué cambia** (lista de archivos).
- **Smoke test** (comando exacto) y **criterio de éxito**.
- **Plan de rollback** (cómo volver al estado anterior en 30 segundos).
- **Compatibilidad mínima**: “Aplica sobre vX.Y.Z (y solo sobre esa)”.

Si falta cualquiera, el patch se considera *NO APLICABLE*.

### R1 — No se toca `main_window.py` sin “compilación” previa
Antes de generar el ZIP:

- `python -m py_compile rcs/ui/main_window.py`
- `python -m py_compile rcs/ui/library_panel.py`
- (si hay más cambios) `python -m py_compile` a **todo archivo .py del patch**.

Cero tolerancia a `IndentationError` / `SyntaxError`.

### R2 — Prohibido introducir referencias a métodos “fantasma”
Si un patch agrega un `.connect(self._algo)` o llama `self._algo(...)`, entonces:

- `def _algo(...):` **debe existir** en el mismo patch (o ya existir en base estable).
- Si es opcional, la conexión debe ser **guarded**:
  - `if hasattr(self, "_algo"): signal.connect(self._algo)`

> Nota: el *guarded connect* es para compatibilidad retro, no para esconder bugs. Si falta el método por error, el smoke test lo tiene que detectar.

### R3 — Un patch = un “surface area” (zona de riesgo)
Regla práctica:

- Si el patch es UI + Library + Models, **se divide**.
- Primero patch “infra” (core/compat), luego patch “feature” (UI), luego patch “wiring” (acciones/botones).

### R4 — Scripts/hotfix *siempre* relativos al repo
Queda prohibido hardcodear cosas como `C:\PROYECTOS\tools\...`.

En scripts:

- `$ROOT = Split-Path -Parent $MyInvocation.MyCommand.Path` (PowerShell)
- `%~dp0` (BAT)
- `Path(__file__).resolve().parents[...]` (Python)

Y todo path target se arma como `Join-Path $ROOT "rcs\ui\main_window.py"`.

### R5 — “Patch Guard” mínimo (pre‑flight)
Antes de extraer el ZIP, el runner debe chequear:

- El ZIP **no contiene** rutas absolutas.
- Todos los archivos extraídos quedan **dentro** de `$ROOT` (no `..\..`).
- Si el patch toca `.py`, corre **py_compile** a esos archivos.
- Si falla cualquier chequeo: **NO EXTRAER** y registrar en log.

### R6 — Matriz de estabilidad (corta, pero real)
Para considerar “estable” un patch UI:

1. Arranca la app (`python -m rcs.app`) sin excepción.
2. Insertar un SVG desde biblioteca funciona.
3. Guardar/cargar proyecto básico funciona.
4. Cerrar sin crash.

---

## Plantilla obligatoria para Patch Notes (copiar/pegar)

Cada nota de patch debe incluir esta cabecera:

```text
BASE: 0.3.10.2.xx
SCOPE: CORE|UI|DOCS|HOTFIX
FILES: (lista)
SMOKE:
  - cmd:
  - expected:
ROLLBACK:
  - cmd/acción:
RISKS:
  - ...
```

---

## Checklist (para ejecución humana, 2 minutos)

Ver `docs/checklist/CHECKLIST_PATCH_GUARD.md`.

